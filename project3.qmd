---
title: "PHP 2550: Project 3"
author: "Peirong Hao"
format: pdf
include-in-header: 
  text: |
    \usepackage{fvextra}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
editor: visual
execute:
  echo: false
  warning: false
  error: false
  eval: true
  output: true
  fig-height: 2
---

# Abstract

This simulation project investigates optimal recruitment designs for cluster-randomized trials within budgetary limitations. The project examines two data-generating models: normally distributed outcomes and poisson-distributed outcomes. Hierarchical data are generated with multiple parameters, such as the number of clusters ($G$), the number of observations per cluster ($R$), and cluster-level variance ($\gamma^2$). The simulation attempts to determine an optimal balance between $G$ and $R$ to reduce estimation variability. The comparative costs of sampling new clusters ($c_1$) versus conducting additional measurements within existing clusters ($c_2$) are adjusted to assess their influence on estimates. Models are fitted using linear mixed-effects models for the normal scenario and generalized linear mixed-effects models for the poisson scenario, with performance assessed through metrics including the variance of estimates and average of estimates' standard errors. Results demonstrate that increasing the number of clusters generally improves precision within fixed budgets, but high cluster-level variance complicates estimation. Furthermore, the increased cluster-level variance amplifies variability in outcomes, making estimation more challenging. These findings provide practical guidance for researchers designing cost-effective cluster-randomized trials.

# Simulation Design Using ADEMP Framework

## Aims

We aim to enhance the design of a cluster-randomized trial by accounting for budget constraints and varying parameters. This project explores two data-generating scenarios: normally distributed outcomes and poisson-distributed outcomes. The simulation focuses on identifying the optimal combination of the number of clusters ($G$) and the number of observations per cluster ($R$) that minimizes estimation variability within a fixed budget ($B$). Moreover, the study investigates the impact of varying the relative costs of sampling the first observation from a cluster ($c_1$) compared to additional measurements within the same cluster ($c_2$) under the condition that $c_1 > c_2$. The analysis further explores how adjustments to model parameters---such as the intercept ($\alpha$), treatment effect ($\beta$), and cluster-level variance ($\gamma^2$)---influence the treatment effect estimates. Finally, it examines the effect of varying the budget ($B$) on the optimal design.

## Data-Generating Mechanisms

We generate the data using hierarchical models. Observations $j$ range from 1 to $R$, representing measurements within each cluster, while clusters $i$ range from 1 to $G$ (the total number of clusters). Treatment assignment ($X_i$) is originally determined by a Bernoulli distribution with a fixed probability of 0.5, ensuring an approximately equal allocation of clusters to treatment and control groups. However, to avoid scenarios where all clusters are assigned to a single group, the assignment is manually balanced. Observations within the same cluster share a cluster-level mean, modeled as $\mu_i = \alpha + \beta X_i + \epsilon_i$, where $\epsilon_i$ represents the cluster-level deviation and follows a distribution $N(0, \gamma^2)$. Individual-level outcomes are generated as $Y_{ij} = \mu_i + e_{ij}$, where $e_{ij}$ reflects within-cluster variation and is drawn from $N(0, \sigma^2)$. For the poisson scenario, the cluster-level mean is modeled on the log scale as $\log(\mu_i) = \alpha + \beta X_i + \epsilon_i$, where $\epsilon_i \sim N(0, \gamma^2)$ captures the cluster-level variability. Individual-level outcomes are generated from a poisson distribution, $Y_{ij} \sim \text{Poisson}(\mu_i)$. Unlike the normal scenario, there is no $\sigma$ parameter in this case because the poisson distribution models variability through its mean, with the variance being equal to the mean.

## Estimands

The primary estimand is the treatment effect ($\beta$), contributing to the outcome difference between the treatment and control groups. In the normal scenario, $\beta$ reflects the difference in cluster-level means between the two groups, while in the poisson scenario, $\beta$ represents the log-scale difference in cluster-level means. Importantly, $\beta$ is an unbiased estimate. The precision and accuracy of $\beta$ are assessed by examining the variance of the estimates and the squared average standard error of the estimates.

## Methods

The simulation generates hierarchical data using the `DataSim()` function, allowing for variation in parameters such as the number of clusters ($G$), the number of observations per cluster ($R$), the cluster-level variance ($\gamma^2$), intercept ($\alpha$), and treatment effect ($\beta$). For each set of parameters, two datasets---one based on normal models and the other on poisson models---are generated per iteration, with multiple iterations conducted in total to ensure robust evaluation. To optimize the recruitment design, the number of clusters ($G$) and the number of observations per cluster ($R$) are determined using the `BudgetOpt()` function, which incorporates the fixed budget ($B$), the cost of sampling from new clusters ($c_1$), and the relative costs of $c_1$ versus $c_2$ (the cost of collecting additional measurements within existing clusters). Constraints like ensuring a minimum of four clusters ($G≥4$) and at least two observations per cluster ($R≥2$) preserve hierarchical order and prevent errors during model fitting. The optimization process starts by determining the maximum feasible number of clusters ($G$) that can be managed within the budget while satisfying the minimum conditions for both $G$ and $R$. For every feasible G value, the associated R values are calculated using the GetR() function. The ultimate sets of G and R values are chosen according to their adherence to all restrictions.

The `ParamVary()` function systematically varies a single parameter---such as $\alpha$, $\beta$, $\gamma$, $c_1$, the relative cost of $c_1$ versus $c_2$, or $B$---while keeping other variables constant. For each parameter configuration, the function generates datasets corresponding to all possible pairs of $G$ and $R$, fits hierarchical models (`lmer()` for normally distributed outcomes and `glmer()` for poisson-distributed outcomes), and saves the estimated $\beta$, standard errors of the estimates, and resource allocation parameters ($G$ and $R$). The MeasureGen() function processes these results, summarizing key metrics such as the variance of the estimated $\beta$ and the mean of squared standard errors for each combination of $G$ and $R$. All simulated datasets and their corresponding performance metrics are stored as CSV files in specified folders for further evaluation and replication. It is important to note that the $\sigma$ value in the normal scenario, indication of within-cluster variability, does not affect the estimation of the treatment effect $\beta$. Since $\beta$ reflects the disparity in cluster-level means between the treated and control groups, this disparity is unaffected by the within-cluster noise $\sigma$. As a result, $\sigma$ can remain constant. Likewise, the intercept parameter $\alpha$ in the normal setting should not influence the estimation of $\beta$, as it denotes a baseline value that shifts all cluster means, irrespective of treatment status. Nonetheless, $\alpha$ may influence the estimation of $\beta$ in the poisson instance, since $\alpha$ influences the cluster mean exponentially, significantly impacting the outcome Y.

## Performance Measures

The performance of the study design is assessed through multiple metrics that evaluate the reliability of the estimated treatment effect. The variance of the estimated $\beta$ quantifies the variability of the estimates across iterations. The mean of the standard errors of estimates is calculated to describe the expected uncertainty in the treatment effect for a single dataset. The simulation also tracks the number of clusters ($G$) and the number of observations per cluster ($R$) within the specified budget constraints.

```{r}
#| label: setup
#| include: false

set.seed(123456)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(grid)
library(purrr)
library(lme4)
library(lmerTest)

library(brms)
library(blme)

library(Rlab)#!!! might not need
```

```{r}
#data generation
#G clusters, each cluster has R members
#clusters are independent
#members in each cluster share same cluster mean (correlated)
DataSim <- function(G, R, alpha, beta, gamma, method, sigma=0.5, p.trt=0.5){
  data <-data.frame(matrix(ncol = 7, nrow = G*R))
  colnames(data) <- c('G', 'R', 'X', 'Y', 'alpha', 'beta', 'gamma')
  # data[,"G"] <- rep(1:G, each=R)
  # data[,"R"] <- rep(1:R, G)
  
  # Generate X: 0 for ctrl, 1 for trt
  #x <- rbern(n=G, prob=p.trt)#not use it because sometimes all xs are 0
  x <- c(rep(0, floor(G / 2)), rep(1, ceiling(G / 2)))
  x <- sample(x)
  
  mu.0 <- alpha + beta * x
  
  epsilon <- rnorm(G, mean=0, sd=gamma)
  mu <- mu.0 + epsilon
  if(method == "poisson"){
      mu <- exp(mu)
    }
  #mu <- ifelse(method=="poisson", exp(mu.0 + epsilon), mu.0 + epsilon)
  
  for(i in 1:G){
    if(method == "poisson"){
      y <- rpois(R, lambda = mu[i]) 
    }
    else{#normal
      eps <- rnorm(n=R, mean=0, sd=sigma)
      y <- mu[i] + eps
    }
    
    for(j in 1:R){
      row.num <- i*R-(R-j)
      data[row.num, ] <- c(i, j, x[i], y[j], 
                           alpha, beta, gamma)
    }
  }
  return(data)
}

#modify!!!
#alpha refers to intercept
#method = "poisson" or "normal"
DataGen <- function(folder.data, filename, alpha, beta, gamma, B, C1, relative.cost, method){
  # Create data folder
  if (!dir.exists(folder.data)) {  # Check if the folder already exists
      dir.create(folder.data)} 
  
  B.Opt <- BudgetOpt(B, C1, relative.cost)
  R <- B.Opt$R
  G <- B.Opt$G
  
  for(k in 1:length(G)){
    # Simulate data
    data <- DataSim(G[k], R[k], alpha, beta, gamma, method)
    
    # Create csv file
    write.csv(data, paste0(folder.data, filename,'_',G[k],'_',R[k],"_data.csv"), row.names=FALSE)
  }
  return(B.Opt)
}

# ##########################################test data generation
# #method="normal"
# method="poisson"
# for(i in 1:2){
#   DataGen(folder.data = "~/Documents/GitHub/PHP2550-PDA-project3/Data/",
#           filename = paste0("sim",'_',i,'_',method), method = method)
# }
# #test1<-read.csv("~/Documents/GitHub/PHP2550-PDA-project3/Data/sim_1_data.csv")
# 
# #method="normal"
# method="poisson"
# folder.data = "~/Documents/GitHub/PHP2550-PDA-project3/Data/"
# filename.data = paste0("sim",'_',i,'_',method)
# data.path = paste0(folder.data, filename.data, "_data.csv")
# #ModelFit(data.path, method=method)
# ##########################################test data generation

#fit hierarchical model
#method = "poisson" or "normal"
ModelFit <- function(data.path, method, true.beta=0.5){
  
  data <- read.csv(data.path)
  
  if(method == "poisson"){
      mdl <- glmer(Y ~ X + (1 | G), data=data, family="poisson")
    }
  else{
      mdl <- lmer(Y ~ X + (1 | G), data=data, control = lmerControl(optimizer = "Nelder_Mead"))
    }
  
  #do not need to worry about p-value < or > alpha=0.05
  #do not need coverage, i.e. 95% CI
  summ <- summary(mdl)
  est.beta <- summ$coefficients["X", "Estimate"]
  se <- summ$coefficients["X", "Std. Error"]

  measure <- c(est.beta, se)
  return(measure)
}


#constraint: G>=4, R>=2 to maintain hierarchical order, o/w error occurs when fitting model
#make sure C1 > C2
BudgetOpt <- function(B, C1, relative.cost){
  C2 <- C1/relative.cost
  G.min <- 4
  R.min <- 2
  B.remain <- B-G.min*C1-(R.min-1)*C2 #remaining budget after satisfying the minimum requirement for G,R
  G.max <- floor(B.remain/(C1+R.min*C2))+G.min 
  #each new cluster has to at least two observation, max.num = potential (integer) + min.num
  
  G.all <- G.min:G.max
  R.all <- sapply(G.all, GetR, B=B, C1=C1, C2=C2)#find the corresponding R for each G
  indices <- which(R.all >= R.min)#have to satisfy this requirement
  
  G.final <- G.all[indices]
  R.final <- R.all[indices]

  return(list(G=G.final, R=R.final))
}

GetR <- function(G, B, C1, C2){
  #constraint: C1*G + C2*G*(R-1) <= B
  R <- floor(1 + (B-C1*G)/(C2*G))
  return(R)
}

#param: C1, relative.cost, beta, gamma, (change alpha only for poisson case)
#do not change p.trt, sigma
#could change B as well
ParamVary <- function(param.ls, param.name, method, max.iter = 5, 
                      folder.data = "~/Documents/GitHub/PHP2550-PDA-project3/Data/",
                      folder.perf = "~/Documents/GitHub/PHP2550-PDA-project3/Perf/",
                      C1=20, relative.cost=2, alpha=5, beta=3, gamma=2, B=5000){
  # Create performance folder
  if (!dir.exists(folder.perf)) {  # Check if the folder already exists
            dir.create(folder.perf)} 
  
  for(i in 1:length(param.ls)){
      param = param.ls[i]
      
      for(j in 1:max.iter){
          
        if(param.name=="C1"){
          filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j)
          B.Opt <- DataGen(folder.data, filename.data, C1=param, method=method,
                  relative.cost=relative.cost, alpha=alpha, beta=beta, gamma=gamma, B=B)
          R <- B.Opt$R
          G <- B.Opt$G
          K <- length(G)
          
          if(j==1){
            perf.measure <- data.frame(matrix(ncol = 4, nrow = max.iter*K))
            colnames(perf.measure) <- c("est.beta", "se", "G", "R")
            }
            
          for(k in 1:K){
            #print(k)
            filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j,'_',G[k],'_',R[k])
            data.path = paste0(folder.data, filename.data, "_data.csv")
            measure <- ModelFit(data.path, method=method)
            
            row.num <- j*K-(K-k)
            perf.measure[row.num, ] <- c(measure[1], measure[2], G[k], R[k])
            }
            
          if(j==max.iter){
            # Create csv file
            filename.perf = paste0("sim",'_',method,'_',param.name,'_',param)
            write.csv(perf.measure, paste0(folder.perf, filename.perf, "_perf.csv"), row.names=FALSE)}
        }
        
        else if(param.name=="relative.cost"){
          # DataGen(folder.data, filename.data, relative.cost=param, method=method,
          #         C1=C1, G=G, alpha=alpha, beta=beta, gamma=gamma, B=B)
          # perf.measure[j,] <- ModelFit(data.path, method=method)
          
          filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j)
          B.Opt <- DataGen(folder.data, filename.data, relative.cost=param, method=method,
                  C1=C1, alpha=alpha, beta=beta, gamma=gamma, B=B)
          R <- B.Opt$R
          G <- B.Opt$G
          K <- length(G)
          
          if(j==1){
            perf.measure <- data.frame(matrix(ncol = 4, nrow = max.iter*K))
            colnames(perf.measure) <- c("est.beta", "se", "G", "R")
            }
            
          for(k in 1:K){
            #print(k)
            filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j,'_',G[k],'_',R[k])
            data.path = paste0(folder.data, filename.data, "_data.csv")
            measure <- ModelFit(data.path, method=method)
            
            row.num <- j*K-(K-k)
            perf.measure[row.num, ] <- c(measure[1], measure[2], G[k], R[k])
            }
            
          if(j==max.iter){
            # Create csv file
            filename.perf = paste0("sim",'_',method,'_',param.name,'_',param)
            write.csv(perf.measure, paste0(folder.perf, filename.perf, "_perf.csv"), row.names=FALSE)}
        }
        else if(param.name=="alpha"){
          # DataGen(folder.data, filename.data, alpha=param, method=method,
          #         relative.cost=relative.cost, G=G, C1=C1, beta=beta, gamma=gamma, B=B)
          # perf.measure[j,] <- ModelFit(data.path, method=method)
          
          filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j)
          B.Opt <- DataGen(folder.data, filename.data, alpha=param, method=method,
                  relative.cost=relative.cost, C1=C1, beta=beta, gamma=gamma, B=B)
          R <- B.Opt$R
          G <- B.Opt$G
          K <- length(G)
          
          if(j==1){
            perf.measure <- data.frame(matrix(ncol = 4, nrow = max.iter*K))
            colnames(perf.measure) <- c("est.beta", "se", "G", "R")
            }
            
          for(k in 1:K){
            #print(k)
            filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j,'_',G[k],'_',R[k])
            data.path = paste0(folder.data, filename.data, "_data.csv")
            measure <- ModelFit(data.path, method=method)
            
            row.num <- j*K-(K-k)
            perf.measure[row.num, ] <- c(measure[1], measure[2], G[k], R[k])
            }
            
          if(j==max.iter){
            # Create csv file
            filename.perf = paste0("sim",'_',method,'_',param.name,'_',param)
            write.csv(perf.measure, paste0(folder.perf, filename.perf, "_perf.csv"), row.names=FALSE)}
          
        }
        else if(param.name=="beta"){
          # DataGen(folder.data, filename.data, beta=param, method=method,
          #         relative.cost=relative.cost, G=G, alpha=alpha, C1=C1, gamma=gamma, B=B)
          # perf.measure[j,] <- ModelFit(data.path, true.beta=param, method=method)
          
          filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j)
          B.Opt <- DataGen(folder.data, filename.data, beta=param, method=method,
                  relative.cost=relative.cost, alpha=alpha, C1=C1, gamma=gamma, B=B)
          R <- B.Opt$R
          G <- B.Opt$G
          K <- length(G)
          
          if(j==1){
            perf.measure <- data.frame(matrix(ncol = 4, nrow = max.iter*K))
            colnames(perf.measure) <- c("est.beta", "se", "G", "R")
            }
            
          for(k in 1:K){
            #print(k)
            filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j,'_',G[k],'_',R[k])
            data.path = paste0(folder.data, filename.data, "_data.csv")
            measure <- ModelFit(data.path, method=method)
            
            row.num <- j*K-(K-k)
            perf.measure[row.num, ] <- c(measure[1], measure[2], G[k], R[k])
            }
            
          if(j==max.iter){
            # Create csv file
            filename.perf = paste0("sim",'_',method,'_',param.name,'_',param)
            write.csv(perf.measure, paste0(folder.perf, filename.perf, "_perf.csv"), row.names=FALSE)}
        }
        else if(param.name=="gamma"){
          # DataGen(folder.data, filename.data, gamma=param, method=method,
          #         relative.cost=relative.cost, G=G, alpha=alpha, beta=beta, C1=C1, B=B)
          # perf.measure[j,] <- ModelFit(data.path, method=method)
          
          filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j)
          B.Opt <- DataGen(folder.data, filename.data, gamma=param, method=method,
                  relative.cost=relative.cost, alpha=alpha, beta=beta, C1=C1, B=B)
          R <- B.Opt$R
          G <- B.Opt$G
          K <- length(G)
          
          if(j==1){
            perf.measure <- data.frame(matrix(ncol = 4, nrow = max.iter*K))
            colnames(perf.measure) <- c("est.beta", "se", "G", "R")
            }
            
          for(k in 1:K){
            #print(k)
            filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j,'_',G[k],'_',R[k])
            data.path = paste0(folder.data, filename.data, "_data.csv")
            measure <- ModelFit(data.path, method=method)
            
            row.num <- j*K-(K-k)
            perf.measure[row.num, ] <- c(measure[1], measure[2], G[k], R[k])
            }
            
          if(j==max.iter){
            # Create csv file
            filename.perf = paste0("sim",'_',method,'_',param.name,'_',param)
            write.csv(perf.measure, paste0(folder.perf, filename.perf, "_perf.csv"), row.names=FALSE)
            }
        }
        else if(param.name=="B"){
          # DataGen(folder.data, filename.data, B=param, method=method,
          #         relative.cost=relative.cost, G=G, alpha=alpha, beta=beta, gamma=gamma, C1=C1)
          # perf.measure[j,] <- ModelFit(data.path, method=method)
          
          filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j)
          B.Opt <- DataGen(folder.data, filename.data, B=param, method=method,
                  relative.cost=relative.cost, alpha=alpha, beta=beta, gamma=gamma, C1=C1)
          R <- B.Opt$R
          G <- B.Opt$G
          K <- length(G)
          
          if(j==1){
            perf.measure <- data.frame(matrix(ncol = 4, nrow = max.iter*K))
            colnames(perf.measure) <- c("est.beta", "se", "G", "R")
            }
            
          for(k in 1:K){
            #print(k)
            filename.data = paste0("sim",'_',method,'_',param.name,'_',param,'_',j,'_',G[k],'_',R[k])
            data.path = paste0(folder.data, filename.data, "_data.csv")
            measure <- ModelFit(data.path, method=method)
            
            row.num <- j*K-(K-k)
            perf.measure[row.num, ] <- c(measure[1], measure[2], G[k], R[k])
            }
            
          if(j==max.iter){
            # Create csv file
            filename.perf = paste0("sim",'_',method,'_',param.name,'_',param)
            write.csv(perf.measure, paste0(folder.perf, filename.perf, "_perf.csv"), row.names=FALSE)}
        }

      }
  }
}

MeasureGen <- function(param.ls, param.name, method, 
                       folder.perf = "~/Documents/GitHub/PHP2550-PDA-project3/Perf"){

  # perf.measure.final <- matrix(NA, nrow = length(param.ls), ncol = 5)
  # colnames(perf.measure.final) <- c(param.name, "sd.est.beta", "avg.se", "G", "R")
  # perf.measure.final[,1] <- param.ls
  
  param.len <- length(param.ls)
  #result.ls <- vector("list", 4*param.len)
  #Each param is associated with one table and three plots
  result.ls <- vector("list", param.len)
  
  for(i in 1:param.len){
    param = param.ls[i]
    file.i <- list.files(path = folder.perf,
                                 pattern = paste0("sim",'_',method,'_',param.name,'_',param), 
                                 full.names = T)  
    file.df <- read.csv(file.i, stringsAsFactors = FALSE, header = TRUE)
    
    #for(j in 1:4){
      # idx <- (i-1)*4+j
      # if(j==1){
        tbl <- file.df %>%
          group_by(G, R) %>%
          summarise(
            Var_Beta_Est = var(est.beta, na.rm = TRUE),  
            Mean_SE_Sq = (mean(se, na.rm = TRUE))^2,
            .groups = "drop")
      
        result.ls[[i]] <- tbl
      #}
      # else{
      #   if(j==2){
      #     plot1 <- ggplot(tbl, aes(x = G, y = R)) +
      #                 geom_bar(stat = "identity", fill = "lightgreen") +
      #                 labs(title = "Recruitment Options",
      #                   x = "G", y = "R") + theme_minimal()
      #     result.ls[[idx]] <- plot1
      #   }
      #   else if(j==2){
      #       plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est)) +
      #                   geom_bar(stat = "identity", fill = "skyblue") +
      #                   labs(
      #                     title = "Variance of Beta Estimates",
      #                     x = "G", y = "Variance of Beta Estimates") + theme_minimal()
      #       result.ls[[idx]] <- plot2
      #   }
      #   else if(j==2){
      #       plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq)) +
      #                   geom_bar(stat = "identity", fill = "purple") +
      #                   labs(
      #                     title = "Mean SE Squared",
      #                     x = "G", y = "Mean SE Squared") + theme_minimal()
      #       result.ls[[idx]] <- plot3
      #   }
      #}
      
    #}

    #perf.measure.final[i,-1] <- c(sd(file.df[,1]), colMeans(file.df[,-1], na.rm = T))
  }
  #print(perf.measure.final)
  #return(perf.measure.final)
  # return(knitr::kable(perf.measure.final,
  #            digits = 5, caption = paste0("Vary ", param, " & Method is ", method)))
  return(result.ls)
}
```

```{r}
#3 common problems:
#boundary (singular) fit: see help('isSingular')

#Error: no more error handlers available (recursive errors?); invoking 'abort' restart

#Warning: type 29 is unimplemented in 'type2char'Error in data.frame(rbind(c("algorithm", "character", paste("NLOPT_GN_DIRECT",  : INTEGER() can only be applied to a 'integer', not a 'unknown type #29'
#Error in summ$coefficients["X", "Estimate"] : subscript out of bounds

#Error in DataSim(G, R, alpha, beta, gamma, method) : INTEGER() can only be applied to a 'integer', not a 'unknown type #29'

#Show in New Window, Error in summ$coefficients["X", "Estimate"] : subscript out of bounds

#Warning: Model failed to converge with max|grad| = 0.218378 (tol = 0.002, component 1)fixed-effect model matrix is rank deficient so dropping 1 column / coefficient fixed-effect model matrix is rank deficient so dropping 1 column / coefficient Error in summ$coefficients["X", "Estimate"] : subscript out of bounds

#Error: no more error handlers available (recursive errors?); invoking 'abort' restart Warning: type 29 is unimplemented in 'type2char'Error in stopifnot(length(class2) == 1L) : INTEGER() can only be applied to a 'integer', not a 'unknown type #29'

method = "normal"
param.name = "C1"
#param.ls = c(6,10,12,16,20)
#param.ls = c(10,20,30,40,50)
#param.ls = c(10,15,20,25,30)
param.ls = c(10,20,30)
ParamVary(param.ls, param.name, method,
          relative.cost=2, alpha=5, beta=3, gamma=2, B=5000)
result.C1.normal <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.C1.normal[[i]]
  
  plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.y = element_text(size = 5),
                    axis.text.x = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.y = element_text(size = 5),
                    axis.text.x = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}

method ="poisson"
ParamVary(param.ls, param.name, method,
          relative.cost=2, alpha=5, beta=3, gamma=2, B=5000)
result.C1.poisson <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.C1.poisson[[i]]
  
    plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}
```

```{r}
#Error in summ$coefficients["X", "Estimate"] : subscript out of bounds
param.name = "relative.cost"
param.ls = c(4, 5, 10)
#param.ls = c(5, 10)

method = "normal"
ParamVary(param.ls, param.name, method,
          C1=20, alpha=5, beta=3, gamma=2, B=5000)
result.rc.normal <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.rc.normal[[i]]
  
   plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}

method ="poisson"
ParamVary(param.ls, param.name, method,
          C1=20, alpha=5, beta=3, gamma=2, B=5000)
result.rc.poisson <- MeasureGen(param.ls, param.name, method)
for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.rc.poisson[[i]]
  
    plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}
```

```{r}
#Error in summ$coefficients["X", "Estimate"] : subscript out of bounds
param.name = "alpha"
#param.ls = c(1,3,5,7,9)
#param.ls = c(1,2,3,4,5)
param.ls = c(5,6,7)

method = "normal"#should not matter
ParamVary(param.ls, param.name, method,
          relative.cost=2, C1=20, beta=3, gamma=2, B=5000)
result.alpha.normal <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.alpha.normal[[i]]
  
    plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}

method ="poisson"
# ParamVary(param.ls, param.name, method,
#           relative.cost=2, C1=20, beta=2, gamma=1, B=5000)
ParamVary(param.ls, param.name, method,
          relative.cost=2, C1=20, beta=3, gamma=2, B=5000)
result.alpha.poisson <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.alpha.poisson[[i]]
  
  plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}
```

```{r}
#Error in summ$coefficients["X", "Estimate"] : subscript out of bounds

#Warning: convergence code 3 from bobyqa: bobyqa -- a trust region step failed to reduce q

#fixed-effect model matrix is rank deficient so dropping 1 column / coefficient
#Error in summ$coefficients["X", "Estimate"] : subscript out of bounds

param.name = "beta"
#param.ls = c(0.1, 0.5, 1, 3, 5)
param.ls = c(1,2,3,4,5)

method = "normal"
# ParamVary(param.ls, param.name, method,
#           relative.cost=2, C1=20, alpha=5, gamma=1, B=5000)
ParamVary(param.ls, param.name, method,
          relative.cost=2, C1=20, alpha=5, gamma=2, B=5000)
result.beta.normal <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.beta.normal[[i]]
  
    plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.y = element_text(size = 5),
                    axis.text.x = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}

method ="poisson"
# ParamVary(param.ls, param.name, method,
#           relative.cost=2, C1=20, alpha=5, gamma=1, B=5000)
ParamVary(param.ls, param.name, method,
           relative.cost=2, C1=20, alpha=5, gamma=2, B=5000)
result.beta.poisson <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.beta.poisson[[i]]
  
    plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}
```

```{r}
#Error in summ$coefficients["X", "Estimate"] : subscript out of bounds
param.name = "gamma"
#param.ls = c(0.5, 1, 2, 3, 4, 5)
#param.ls = c(2, 2.5, 3)
#param.ls = c(2,3)
param.ls = c(1,2,3)
#param.ls = c(1, 1.5, 2)
method = "normal"
ParamVary(param.ls, param.name, method,
          relative.cost=2, C1=20, alpha=5, beta=3, B=5000)
result.gamma.normal <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.gamma.normal[[i]]
  
    plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}

method ="poisson"
ParamVary(param.ls, param.name, method,
          relative.cost=2, C1=20, alpha=5, beta=3, B=5000)
result.gamma.poisson <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.gamma.poisson[[i]]
  
  plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}
```

```{r}
#fixed-effect model matrix is rank deficient so dropping 1 column / coefficient
#Error in summ$coefficients["X", "Estimate"] : subscript out of bounds
param.name = "B"
#param.ls = c(1000, 1500, 2000, 2500, 3000)
#param.ls = c(3000, 3500, 4000)
param.ls = c(3000, 4000, 5000)

method = "normal"
# ParamVary(param.ls, param.name, method,
#           relative.cost=2, C1=20, alpha=5, beta=3, gamma=1)
ParamVary(param.ls, param.name, method,
          relative.cost=2, C1=20, alpha=5, beta=3, gamma=2)
result.B.normal <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.B.normal[[i]]
  
  plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.x = element_text(size = 5),
                    axis.text.y = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}

method ="poisson"
ParamVary(param.ls, param.name, method,
          relative.cost=2, C1=20, alpha=5, beta=3, gamma=2)
result.B.poisson <- MeasureGen(param.ls, param.name, method)

for(i in 1:length(param.ls)){
  param = param.ls[i]
  tbl <- result.B.poisson[[i]]
  
  plot1 <- ggplot(tbl, aes(x = G, y = R, group = 1)) +
              geom_line(color = "lightgreen", linewidth = 1) + 
              geom_point(color = "lightgreen", size = 2) +  
              labs(title = "Recruitment Options", x = "G", y = "R") +
              theme_minimal() + ylim(0, 700) + xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.y = element_text(size = 5),
                    axis.text.x = element_text(size = 5))
  
  plot2 <- ggplot(tbl, aes(x = G, y = Var_Beta_Est, group = 1)) +
              geom_line(color = "skyblue", linewidth = 1) +  
              geom_point(color = "skyblue", size = 2) +  
              labs(title = "Variance of Beta Estimates",x = "G",y = "Variance of Beta Estimates") +
              theme_minimal() + ylim(0, 15)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.y = element_text(size = 5),
                    axis.text.x = element_text(size = 5))
              
  plot3 <- ggplot(tbl, aes(x = G, y = Mean_SE_Sq, group = 1)) +
              geom_line(color = "purple", linewidth = 1) +  
              geom_point(color = "purple", size = 2) +  
              labs(title = "Mean SE Squared",x = "G",y = "Mean SE Squared") +
              theme_minimal() + ylim(0, 10)+ xlim(0, 275)+
              theme(plot.title = element_text(size = 5),
                    axis.text.y = element_text(size = 5),
                    axis.text.x = element_text(size = 5))
  
  header <- textGrob(paste0(method,', ',param.name,'=',param), 
                     gp = gpar(fontsize = 7, fontface = "bold"))

  grid.arrange(header,arrangeGrob(plot1, plot2, plot3, nrow = 1),heights = c(0.05, 1))
}
```

# Analysis and Results

The default parameters used in the simulations are $B=5000$, $C_1 = 20$, relative cost of $C_1$ versus $C_2 = 2$, $\alpha = 5$, $\beta = 3$, $\gamma = 2$, and $\sigma = 0.5$. When one variable changes, the others remain constant to isolate its effect. Comparisons are made by examining all generated plots. Simulations demonstrated that increasing the number of clusters ($G$) improves the reliability of treatment effect estimates, as both the variance of beta estimates and the mean squared standard errors decrease. Unsurprisingly, due to budget constraints, the number of observations per cluster ($R$) decreases as $G$ increases. When $C_1$ (the cost per new cluster) increases, the maximum number of clusters ($G$) decreases because recruiting new clusters becomes more expensive. Similarly, as the relative cost increases, it becomes more economical to continue collecting observations within existing clusters, increasing R. Changes in $\alpha$ and $\beta$ positively influence the variance of beta estimates. At the same time, $\gamma$ strongly impacts the variance of beta estimates, underscoring its critical role in trial design. Increasing the budget ($B$) allows for more clusters to be included but does not affect the variance of beta estimates or the mean squared standard errors. These findings highlight the trade-offs in balancing cluster recruitment and within-cluster observations under budget constraints.

# Limitations

The simulations offer data-driven insights into the design of cluster-randomized trials; however, several limitations should be acknowledged. Firstly, the models rely on simplified hierarchical frameworks with independent clusters, but clusters can have dependencies in reality. Moreover, the simulations do not account for missing data and imbalanced treatment, which are common challenges in real life. Furthermore, we assume no measurement error and unobserved confounding, which may oversimplify the real-world problems. Due to time constraints, the maximum number of iterations (max.iter) was limited to 5, which may have influenced the findings. Running simulations with more iterations could provide more reliable results. Future research addressing these limitations can provide a deeper understanding of the trade-offs in designing cost-effective cluster-randomized trials.

\newpage

# Appendix Figures

# Code Appendix

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```
